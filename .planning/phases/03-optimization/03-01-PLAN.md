---
phase: 03-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tributary/analytics/optimization/__init__.py
  - src/tributary/analytics/optimization/almgren_chriss.py
  - tests/unit/test_almgren_chriss.py
autonomous: true

must_haves:
  truths:
    - "User can calibrate Almgren-Chriss parameters from daily volume, spread, and volatility"
    - "User can generate optimal execution trajectories for a given order and risk aversion"
    - "Risk-neutral trajectory (lambda=0) equals TWAP (linear liquidation)"
    - "Higher risk aversion produces more front-loaded execution"
  artifacts:
    - path: "src/tributary/analytics/optimization/almgren_chriss.py"
      provides: "AlmgrenChrissParams dataclass, calibrate_ac_params(), generate_ac_trajectory()"
      exports: ["AlmgrenChrissParams", "ExecutionTrajectory", "calibrate_ac_params", "generate_ac_trajectory"]
    - path: "tests/unit/test_almgren_chriss.py"
      provides: "Unit tests for A-C parameter calibration and trajectory generation"
      min_lines: 150
  key_links:
    - from: "src/tributary/analytics/optimization/almgren_chriss.py"
      to: "src/tributary/analytics/impact.py"
      via: "CalibrationResult optional integration"
      pattern: "CalibrationResult|source_calibration"
---

<objective>
Implement Almgren-Chriss optimal execution framework: parameter calibration from market data and trajectory generation using the standard hyperbolic solution.

Purpose: Almgren-Chriss is the foundational framework for optimal execution. It balances market impact costs against timing risk through mean-variance optimization. This plan provides the core algorithm that Phase 4 simulation will validate.

Output:
- `AlmgrenChrissParams` dataclass with eta, gamma, sigma, alpha, tau
- `calibrate_ac_params()` function deriving A-C parameters from market data
- `ExecutionTrajectory` dataclass for all execution strategies
- `generate_ac_trajectory()` function computing optimal holdings/trade sizes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-optimization/03-RESEARCH.md

# Phase 2 infrastructure this builds on
@src/tributary/analytics/impact.py
@src/tributary/analytics/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AlmgrenChrissParams and calibration function</name>
  <files>
    src/tributary/analytics/optimization/__init__.py
    src/tributary/analytics/optimization/almgren_chriss.py
  </files>
  <action>
Create the optimization subpackage and implement Almgren-Chriss parameter calibration.

**Create `src/tributary/analytics/optimization/__init__.py`:**
- Empty for now, will be populated in Task 2

**Create `src/tributary/analytics/optimization/almgren_chriss.py`:**

1. Add module docstring explaining A-C framework and its role in optimal execution

2. Import dependencies:
   - `dataclasses.dataclass, field`
   - `typing.List, Optional`
   - `numpy as np`
   - `CalibrationResult` from `tributary.analytics.impact` (for optional integration)

3. Create `AlmgrenChrissParams` frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class AlmgrenChrissParams:
       """Calibrated parameters for Almgren-Chriss optimal execution.

       Attributes:
           eta: Temporary impact coefficient (cost per unit traded per time)
           gamma: Permanent impact coefficient (persistent price move per unit)
           sigma: Volatility (price standard deviation per period)
           alpha: Impact exponent from square-root model (typically 0.5)
           tau: Time interval between trades (default 1.0)
           source_calibration: Optional reference to CalibrationResult from impact.py
           warnings: List of validation/calibration warnings
       """
       eta: float
       gamma: float
       sigma: float
       alpha: float
       tau: float
       source_calibration: Optional[CalibrationResult] = None
       warnings: tuple = field(default_factory=tuple)  # tuple for frozen
   ```

4. Create `calibrate_ac_params()` function:
   ```python
   def calibrate_ac_params(
       daily_volume: float,
       daily_spread: float,
       daily_volatility: float,
       price: float,
       alpha: float = 0.5,
       tau: float = 1.0,
       source_calibration: Optional[CalibrationResult] = None,
   ) -> AlmgrenChrissParams:
   ```

   Implementation:
   - Validate inputs (daily_volume > 0, daily_spread >= 0, daily_volatility >= 0, price > 0)
   - Return params with NaN values and warning if validation fails
   - Calculate eta using heuristic: 1% ADV causes temp impact of full spread
     - `eta = daily_spread / (0.01 * daily_volume)`
   - Calculate gamma using heuristic: 10% ADV causes perm impact of full spread
     - `gamma = daily_spread / (0.10 * daily_volume)`
   - Calculate sigma as absolute volatility: `sigma = daily_volatility * price`
   - Validate eta_tilde constraint: `eta_tilde = eta - 0.5 * gamma * tau`
   - Add warning if eta_tilde <= 0 (model constraints violated)
   - Return AlmgrenChrissParams with all values and any warnings

5. Create `ExecutionTrajectory` frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class ExecutionTrajectory:
       """Optimal execution trajectory from any strategy.

       Attributes:
           timestamps: Time points (0, 1, 2, ..., T) or actual timestamps
           holdings: Remaining position at each time (starts at order_size, ends at 0)
           trade_sizes: Size to execute at each interval (length = T)
           strategy_name: 'almgren_chriss', 'twap', 'vwap', or 'market_order'
           total_cost_estimate: Expected total cost in basis points
           risk_aversion: Lambda parameter (0 for TWAP, inf for market order)
           params: Optional strategy-specific parameters
       """
       timestamps: np.ndarray
       holdings: np.ndarray
       trade_sizes: np.ndarray
       strategy_name: str
       total_cost_estimate: float
       risk_aversion: float
       params: Optional[dict] = None
   ```

**Conventions:**
- Follow Phase 2 patterns: frozen dataclasses, docstrings with Attributes section
- Use float('nan') for invalid inputs (consistent with benchmarks.py)
- Positive slippage = cost convention maintained
  </action>
  <verify>
  - File exists: `src/tributary/analytics/optimization/__init__.py`
  - File exists: `src/tributary/analytics/optimization/almgren_chriss.py`
  - Python syntax valid: `python -c "from tributary.analytics.optimization.almgren_chriss import AlmgrenChrissParams, calibrate_ac_params, ExecutionTrajectory"`
  </verify>
  <done>
  - AlmgrenChrissParams dataclass created with eta, gamma, sigma, alpha, tau, source_calibration, warnings
  - calibrate_ac_params() derives parameters from market data using Almgren-Chriss heuristics
  - ExecutionTrajectory dataclass created for representing any execution schedule
  - Validation produces warnings for invalid inputs or eta_tilde constraint violation
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trajectory generation and tests</name>
  <files>
    src/tributary/analytics/optimization/almgren_chriss.py
    src/tributary/analytics/optimization/__init__.py
    src/tributary/analytics/__init__.py
    tests/unit/test_almgren_chriss.py
  </files>
  <action>
Implement the Almgren-Chriss trajectory generation algorithm and comprehensive tests.

**Add to `src/tributary/analytics/optimization/almgren_chriss.py`:**

1. Create `generate_ac_trajectory()` function:
   ```python
   def generate_ac_trajectory(
       order_size: float,
       duration_periods: int,
       params: AlmgrenChrissParams,
       risk_aversion: float = 1e-6,
   ) -> ExecutionTrajectory:
   ```

   Implementation:
   - Handle invalid inputs (order_size <= 0, duration_periods <= 0):
     - Return trajectory with NaN arrays and warning in params

   - Handle risk-neutral case (risk_aversion == 0 or < 1e-10):
     - Linear liquidation (TWAP): `holdings[t] = order_size * (1 - t/T)`
     - `trade_sizes = order_size / T` for all periods
     - Return with strategy_name='almgren_chriss', total_cost_estimate from impact model

   - Compute adjusted parameters:
     - `eta_tilde = params.eta - 0.5 * params.gamma * params.tau`
     - If eta_tilde <= 0: fall back to TWAP, add warning to params

   - Compute kappa (decay rate):
     - `kappa_tilde_sq = (risk_aversion * params.sigma**2) / eta_tilde`
     - `kappa = np.arccosh(0.5 * kappa_tilde_sq * params.tau**2 + 1) / params.tau`

   - Generate trajectory using sinh formula:
     - `holdings[t] = order_size * np.sinh(kappa * (T - t)) / np.sinh(kappa * T)`
     - `trade_sizes = -np.diff(holdings)`  (positive values)

   - Estimate total cost using A-C expected cost formula:
     - `expected_cost = 0.5 * params.gamma * order_size**2 + params.eta * sum(trade_sizes**2) / params.tau`
     - Convert to bps: `total_cost_bps = expected_cost / (order_size * price) * 10000`
     - Use params.sigma / params.daily_volatility to get price, or store price in params

   - Return ExecutionTrajectory with:
     - timestamps: np.arange(duration_periods + 1)
     - holdings, trade_sizes computed above
     - strategy_name: 'almgren_chriss'
     - total_cost_estimate: computed bps
     - risk_aversion: input value
     - params: dict with kappa, eta_tilde for debugging

**Update `src/tributary/analytics/optimization/__init__.py`:**
```python
"""Optimization module for optimal execution strategies."""

from tributary.analytics.optimization.almgren_chriss import (
    AlmgrenChrissParams,
    ExecutionTrajectory,
    calibrate_ac_params,
    generate_ac_trajectory,
)

__all__ = [
    "AlmgrenChrissParams",
    "ExecutionTrajectory",
    "calibrate_ac_params",
    "generate_ac_trajectory",
]
```

**Update `src/tributary/analytics/__init__.py`:**
- Add imports from optimization subpackage:
  ```python
  from tributary.analytics.optimization import (
      AlmgrenChrissParams,
      ExecutionTrajectory,
      calibrate_ac_params,
      generate_ac_trajectory,
  )
  ```
- Add to `__all__` list

**Create `tests/unit/test_almgren_chriss.py`:**

Test AlmgrenChrissParams:
- test_params_creation_with_defaults
- test_params_creation_with_source_calibration
- test_params_is_frozen

Test calibrate_ac_params:
- test_calibrate_basic (standard inputs)
- test_calibrate_eta_calculation (verify 1% ADV = full spread)
- test_calibrate_gamma_calculation (verify 10% ADV = full spread)
- test_calibrate_sigma_calculation (volatility * price)
- test_calibrate_with_source_calibration
- test_calibrate_invalid_volume_zero
- test_calibrate_invalid_volume_negative
- test_calibrate_eta_tilde_warning (gamma > eta scenario)
- test_calibrate_zero_spread (edge case, should work)

Test ExecutionTrajectory:
- test_trajectory_creation
- test_trajectory_is_frozen

Test generate_ac_trajectory:
- test_generate_risk_neutral_equals_twap (lambda=0 => linear)
- test_generate_front_loaded_with_high_lambda (lambda large => more in first periods)
- test_generate_holdings_start_at_order_size
- test_generate_holdings_end_at_zero (approximately)
- test_generate_trade_sizes_sum_to_order_size
- test_generate_trade_sizes_all_positive
- test_generate_invalid_order_size_zero
- test_generate_invalid_order_size_negative
- test_generate_invalid_duration_zero
- test_generate_eta_tilde_violation_fallback_to_twap
- test_generate_increasing_lambda_more_front_loaded (compare multiple lambdas)

Integration tests:
- test_calibrate_then_generate (round-trip)
- test_imports_from_analytics_package
  </action>
  <verify>
  - All tests pass: `pytest tests/unit/test_almgren_chriss.py -v`
  - Import from package works: `python -c "from tributary.analytics import calibrate_ac_params, generate_ac_trajectory, AlmgrenChrissParams, ExecutionTrajectory; print('OK')"`
  </verify>
  <done>
  - generate_ac_trajectory() implements the hyperbolic sinh/cosh solution
  - Risk-neutral case (lambda=0) produces linear (TWAP) liquidation
  - Higher risk aversion produces front-loaded execution
  - Invalid eta_tilde falls back to TWAP with warning
  - Total cost estimated in basis points
  - All tests pass (20+ test cases)
  - Exports available from tributary.analytics package
  </done>
</task>

</tasks>

<verification>
- Import test: `python -c "from tributary.analytics import calibrate_ac_params, generate_ac_trajectory"`
- Unit tests: `pytest tests/unit/test_almgren_chriss.py -v`
- Quick smoke test:
  ```python
  from tributary.analytics import calibrate_ac_params, generate_ac_trajectory

  # Calibrate from typical Polymarket data
  params = calibrate_ac_params(
      daily_volume=50000,
      daily_spread=0.02,  # 2 cents spread
      daily_volatility=0.05,  # 5% daily vol
      price=0.50,
  )
  print(f"eta={params.eta:.6f}, gamma={params.gamma:.6f}")

  # Generate trajectory for $5000 order over 10 periods
  traj = generate_ac_trajectory(
      order_size=5000,
      duration_periods=10,
      params=params,
      risk_aversion=1e-5,
  )
  print(f"First trade: {traj.trade_sizes[0]:.0f}, Last trade: {traj.trade_sizes[-1]:.0f}")
  print(f"Expected cost: {traj.total_cost_estimate:.1f} bps")
  ```
</verification>

<success_criteria>
- AlmgrenChrissParams and ExecutionTrajectory dataclasses work as frozen, immutable types
- calibrate_ac_params() derives sensible parameters from market data
- generate_ac_trajectory() produces valid trajectories for all valid inputs
- Risk-neutral trajectory (lambda=0) equals TWAP
- Increasing lambda produces progressively front-loaded execution
- All tests pass
- Exports available from tributary.analytics package
</success_criteria>

<output>
After completion, create `.planning/phases/03-optimization/03-01-SUMMARY.md`
</output>
