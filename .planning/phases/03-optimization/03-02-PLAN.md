---
phase: 03-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tributary/analytics/optimization/strategies.py
  - src/tributary/analytics/optimization/__init__.py
  - tests/unit/test_strategies.py
autonomous: true

must_haves:
  truths:
    - "User can generate TWAP trajectory that divides order evenly across time"
    - "User can generate VWAP trajectory weighted by historical volume profile"
    - "User can generate market order baseline (single immediate execution)"
    - "All strategies return consistent ExecutionTrajectory format"
  artifacts:
    - path: "src/tributary/analytics/optimization/strategies.py"
      provides: "generate_twap_trajectory(), generate_vwap_trajectory(), generate_market_order_trajectory()"
      exports: ["generate_twap_trajectory", "generate_vwap_trajectory", "generate_market_order_trajectory"]
    - path: "tests/unit/test_strategies.py"
      provides: "Unit tests for TWAP, VWAP, and market order strategies"
      min_lines: 180
  key_links:
    - from: "src/tributary/analytics/optimization/strategies.py"
      to: "src/tributary/analytics/optimization/almgren_chriss.py"
      via: "ExecutionTrajectory dataclass"
      pattern: "from.*almgren_chriss import ExecutionTrajectory"
    - from: "src/tributary/analytics/optimization/strategies.py"
      to: "src/tributary/analytics/reader.py"
      via: "QuestDBReader for volume profiles"
      pattern: "QuestDBReader|query_vwap_sampled"
---

<objective>
Implement baseline execution strategies: TWAP, VWAP, and market order. These provide comparison baselines for Almgren-Chriss optimization and are required for Phase 4 simulation.

Purpose: TWAP and VWAP are industry-standard benchmarks. Market order represents the "naive" baseline. Comparing A-C trajectories against these baselines demonstrates the value of optimal execution.

Output:
- `generate_twap_trajectory()` - Time-weighted equal slices with optional randomization
- `generate_vwap_trajectory()` - Volume-weighted slices from historical profile
- `generate_market_order_trajectory()` - Single immediate execution (maximum impact)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-optimization/03-RESEARCH.md

# Plan 1 provides ExecutionTrajectory dataclass
@src/tributary/analytics/optimization/almgren_chriss.py

# Reader provides volume profile queries
@src/tributary/analytics/reader.py
@src/tributary/analytics/benchmarks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TWAP and market order strategies</name>
  <files>
    src/tributary/analytics/optimization/strategies.py
  </files>
  <action>
Create the strategies module with TWAP and market order baseline.

**Create `src/tributary/analytics/optimization/strategies.py`:**

1. Add module docstring:
   ```python
   """Baseline execution strategies: TWAP, VWAP, and market order.

   These strategies provide comparison baselines for Almgren-Chriss optimization.
   Unlike benchmarks.py (which calculates achieved prices from historical trades),
   this module generates FUTURE execution schedules.

   Key distinction:
   - Benchmarks (Phase 2): What price DID we achieve? (backward-looking)
   - Strategies (Phase 3): What trades SHOULD we execute? (forward-looking)
   """
   ```

2. Import dependencies:
   - `typing.Optional`
   - `numpy as np`
   - `ExecutionTrajectory` from `.almgren_chriss`

3. Create `generate_twap_trajectory()`:
   ```python
   def generate_twap_trajectory(
       order_size: float,
       duration_periods: int,
       randomize: bool = False,
       random_pct: float = 0.1,
       seed: Optional[int] = None,
   ) -> ExecutionTrajectory:
       """
       Generate Time-Weighted Average Price execution trajectory.

       Divides order evenly across time periods. Optional randomization
       adds variation to slice sizes to avoid detection/gaming.

       Args:
           order_size: Total size to execute
           duration_periods: Number of execution intervals
           randomize: If True, add random variation to slice sizes
           random_pct: Maximum random variation as fraction (default 10%)
           seed: Optional random seed for reproducibility

       Returns:
           ExecutionTrajectory with strategy_name='twap'

       Note:
           - risk_aversion = 0 (risk-neutral strategy)
           - total_cost_estimate = 0 (no impact model, just schedule)
       """
   ```

   Implementation:
   - Validate inputs (order_size > 0, duration_periods > 0)
   - If invalid: return trajectory with NaN arrays

   - Calculate base slice: `base_slice = order_size / duration_periods`

   - If randomize:
     - Create RNG: `rng = np.random.default_rng(seed)`
     - Generate variations: `rng.uniform(1 - random_pct, 1 + random_pct, duration_periods)`
     - Multiply base_slice by variations
     - Adjust last slice to ensure exact total: `trade_sizes[-1] = order_size - trade_sizes[:-1].sum()`
   - Else:
     - `trade_sizes = np.full(duration_periods, base_slice)`

   - Calculate holdings from trade sizes:
     - `holdings[0] = order_size`
     - `holdings[i+1] = holdings[i] - trade_sizes[i]`

   - Return ExecutionTrajectory:
     - timestamps: np.arange(duration_periods + 1)
     - holdings: array
     - trade_sizes: array
     - strategy_name: 'twap'
     - total_cost_estimate: 0.0 (schedule only, no cost model)
     - risk_aversion: 0.0

4. Create `generate_market_order_trajectory()`:
   ```python
   def generate_market_order_trajectory(
       order_size: float,
   ) -> ExecutionTrajectory:
       """
       Generate market order trajectory (single immediate execution).

       Represents the "naive" baseline: execute everything immediately,
       accepting maximum market impact.

       Args:
           order_size: Total size to execute

       Returns:
           ExecutionTrajectory with strategy_name='market_order'

       Note:
           - Single period execution (duration=1)
           - risk_aversion = float('inf') (infinitely risk-averse about timing)
           - total_cost_estimate = 0 (actual cost depends on orderbook)
       """
   ```

   Implementation:
   - Validate order_size > 0
   - If invalid: return trajectory with NaN arrays

   - Create single-slice trajectory:
     - timestamps: np.array([0, 1])
     - holdings: np.array([order_size, 0])
     - trade_sizes: np.array([order_size])
     - strategy_name: 'market_order'
     - total_cost_estimate: 0.0
     - risk_aversion: float('inf')
  </action>
  <verify>
  - File exists: `src/tributary/analytics/optimization/strategies.py`
  - Python syntax valid: `python -c "from tributary.analytics.optimization.strategies import generate_twap_trajectory, generate_market_order_trajectory"`
  </verify>
  <done>
  - generate_twap_trajectory() creates equal-slice schedules with optional randomization
  - generate_market_order_trajectory() creates single-slice immediate execution
  - Both return consistent ExecutionTrajectory format
  - Invalid inputs return trajectories with NaN arrays
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement VWAP strategy and tests</name>
  <files>
    src/tributary/analytics/optimization/strategies.py
    src/tributary/analytics/optimization/__init__.py
    src/tributary/analytics/__init__.py
    tests/unit/test_strategies.py
  </files>
  <action>
Add VWAP strategy and comprehensive tests for all baseline strategies.

**Add to `src/tributary/analytics/optimization/strategies.py`:**

1. Add imports at top:
   - `from datetime import datetime`
   - `pandas as pd`
   - `QuestDBReader` from `tributary.analytics.reader`

2. Create `generate_vwap_trajectory()`:
   ```python
   def generate_vwap_trajectory(
       order_size: float,
       volume_profile: np.ndarray,
   ) -> ExecutionTrajectory:
       """
       Generate Volume-Weighted Average Price execution trajectory.

       Weights execution by expected volume at each interval. Attempts to
       match the natural volume pattern to minimize market impact.

       Args:
           order_size: Total size to execute
           volume_profile: Expected volume at each interval (will be normalized)
                          Length determines number of execution periods

       Returns:
           ExecutionTrajectory with strategy_name='vwap'

       Note:
           - Falls back to TWAP if volume_profile sums to 0
           - risk_aversion = 0 (risk-neutral strategy)
       """
   ```

   Implementation:
   - Validate inputs (order_size > 0, volume_profile not empty)
   - If invalid: return trajectory with NaN arrays

   - Normalize volume profile to weights:
     - `total_volume = volume_profile.sum()`
     - If total_volume == 0: fall back to TWAP (uniform weights)
     - Else: `weights = volume_profile / total_volume`

   - Allocate order by weights: `trade_sizes = order_size * weights`

   - Calculate holdings:
     - `holdings[0] = order_size`
     - `holdings[i+1] = holdings[i] - trade_sizes[i]`

   - Return ExecutionTrajectory:
     - timestamps: np.arange(len(volume_profile) + 1)
     - holdings, trade_sizes: computed arrays
     - strategy_name: 'vwap'
     - total_cost_estimate: 0.0
     - risk_aversion: 0.0
     - params: {'volume_profile_sum': total_volume}

3. Create `get_volume_profile_from_db()` convenience function:
   ```python
   def get_volume_profile_from_db(
       reader: QuestDBReader,
       market_id: str,
       start_time: datetime,
       end_time: datetime,
       interval: str = "1h",
   ) -> np.ndarray:
       """
       Query historical volume profile from QuestDB.

       Uses query_vwap_sampled() to get time-bucketed volumes.

       Args:
           reader: Connected QuestDBReader
           market_id: Market identifier
           start_time: Start of historical period
           end_time: End of historical period
           interval: Time bucket interval (e.g., "1h", "15m")

       Returns:
           numpy array of volumes per interval

       Note:
           Returns empty array if no data found.
       """
   ```

   Implementation:
   - Call reader.query_vwap_sampled()
   - Extract 'volume' column as numpy array
   - Return empty array if DataFrame is empty

**Update `src/tributary/analytics/optimization/__init__.py`:**
```python
from tributary.analytics.optimization.almgren_chriss import (
    AlmgrenChrissParams,
    ExecutionTrajectory,
    calibrate_ac_params,
    generate_ac_trajectory,
)
from tributary.analytics.optimization.strategies import (
    generate_twap_trajectory,
    generate_vwap_trajectory,
    generate_market_order_trajectory,
    get_volume_profile_from_db,
)

__all__ = [
    "AlmgrenChrissParams",
    "ExecutionTrajectory",
    "calibrate_ac_params",
    "generate_ac_trajectory",
    "generate_twap_trajectory",
    "generate_vwap_trajectory",
    "generate_market_order_trajectory",
    "get_volume_profile_from_db",
]
```

**Update `src/tributary/analytics/__init__.py`:**
- Add strategy imports to the existing optimization imports
- Add to __all__

**Create `tests/unit/test_strategies.py`:**

Test generate_twap_trajectory:
- test_twap_basic (equal slices)
- test_twap_holdings_start_at_order_size
- test_twap_holdings_end_at_zero
- test_twap_trade_sizes_sum_to_order_size
- test_twap_all_slices_equal (when not randomized)
- test_twap_randomized_slices_vary
- test_twap_randomized_still_sums_to_total
- test_twap_randomized_with_seed_reproducible
- test_twap_strategy_name_is_twap
- test_twap_risk_aversion_is_zero
- test_twap_invalid_order_size_zero
- test_twap_invalid_order_size_negative
- test_twap_invalid_duration_zero

Test generate_vwap_trajectory:
- test_vwap_basic (weighted by volume)
- test_vwap_higher_volume_larger_slice
- test_vwap_holdings_start_at_order_size
- test_vwap_holdings_end_at_zero
- test_vwap_trade_sizes_sum_to_order_size
- test_vwap_uniform_volume_equals_twap
- test_vwap_zero_total_volume_fallback_to_twap
- test_vwap_strategy_name_is_vwap
- test_vwap_invalid_order_size
- test_vwap_empty_volume_profile

Test generate_market_order_trajectory:
- test_market_order_single_slice
- test_market_order_holdings_start_at_order_size
- test_market_order_holdings_end_at_zero
- test_market_order_strategy_name
- test_market_order_risk_aversion_is_inf
- test_market_order_invalid_order_size

Test get_volume_profile_from_db:
- test_get_volume_profile_returns_array (mock reader)
- test_get_volume_profile_empty_result (mock reader returns empty)

Integration tests:
- test_all_strategies_return_execution_trajectory
- test_imports_from_analytics_package
- test_twap_vwap_market_order_comparable_format
  </action>
  <verify>
  - All tests pass: `pytest tests/unit/test_strategies.py -v`
  - Import from package works: `python -c "from tributary.analytics import generate_twap_trajectory, generate_vwap_trajectory, generate_market_order_trajectory; print('OK')"`
  </verify>
  <done>
  - generate_vwap_trajectory() weights execution by volume profile
  - get_volume_profile_from_db() provides convenience query
  - All three strategies return consistent ExecutionTrajectory format
  - TWAP with uniform volume equals VWAP result
  - All tests pass (25+ test cases)
  - Exports available from tributary.analytics package
  </done>
</task>

</tasks>

<verification>
- Import test: `python -c "from tributary.analytics import generate_twap_trajectory, generate_vwap_trajectory, generate_market_order_trajectory"`
- Unit tests: `pytest tests/unit/test_strategies.py -v`
- Quick smoke test:
  ```python
  from tributary.analytics import (
      generate_twap_trajectory,
      generate_vwap_trajectory,
      generate_market_order_trajectory,
  )
  import numpy as np

  # TWAP: 10 equal slices
  twap = generate_twap_trajectory(order_size=1000, duration_periods=10)
  print(f"TWAP slices: {twap.trade_sizes}")  # All equal

  # VWAP: weighted by volume
  volume_profile = np.array([100, 200, 300, 200, 100])  # Bell curve
  vwap = generate_vwap_trajectory(order_size=1000, volume_profile=volume_profile)
  print(f"VWAP slices: {vwap.trade_sizes}")  # Peak in middle

  # Market order: single immediate execution
  mkt = generate_market_order_trajectory(order_size=1000)
  print(f"Market order: {mkt.trade_sizes}")  # [1000]
  ```
</verification>

<success_criteria>
- generate_twap_trajectory() produces equal slices (or randomized with sum constraint)
- generate_vwap_trajectory() produces volume-weighted slices
- generate_market_order_trajectory() produces single-slice immediate execution
- All strategies return consistent ExecutionTrajectory format
- Invalid inputs handled gracefully with NaN arrays
- All tests pass
- Exports available from tributary.analytics package
</success_criteria>

<output>
After completion, create `.planning/phases/03-optimization/03-02-SUMMARY.md`
</output>
