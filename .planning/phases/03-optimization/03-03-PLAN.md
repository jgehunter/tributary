---
phase: 03-optimization
plan: 03
type: execute
wave: 2
depends_on: [03-01, 03-02]
files_modified:
  - src/tributary/analytics/optimization/scheduler.py
  - src/tributary/analytics/optimization/comparison.py
  - src/tributary/analytics/optimization/__init__.py
  - src/tributary/analytics/__init__.py
  - tests/unit/test_scheduler.py
  - tests/unit/test_comparison.py
autonomous: true

must_haves:
  truths:
    - "User can optimize trade schedule given order size, time horizon, and constraints"
    - "User can compare multiple strategy trajectories side-by-side"
    - "Comparison shows expected cost, risk, and execution profile for each strategy"
    - "Scheduler respects participation rate constraints"
  artifacts:
    - path: "src/tributary/analytics/optimization/scheduler.py"
      provides: "TradeSchedule dataclass, optimize_schedule()"
      exports: ["TradeSchedule", "optimize_schedule"]
    - path: "src/tributary/analytics/optimization/comparison.py"
      provides: "StrategyComparison dataclass, compare_strategies()"
      exports: ["StrategyComparison", "compare_strategies"]
    - path: "tests/unit/test_scheduler.py"
      provides: "Unit tests for trade scheduler"
      min_lines: 100
    - path: "tests/unit/test_comparison.py"
      provides: "Unit tests for strategy comparison"
      min_lines: 80
  key_links:
    - from: "src/tributary/analytics/optimization/scheduler.py"
      to: "src/tributary/analytics/optimization/almgren_chriss.py"
      via: "Uses generate_ac_trajectory for optimization"
      pattern: "generate_ac_trajectory|AlmgrenChrissParams"
    - from: "src/tributary/analytics/optimization/comparison.py"
      to: "src/tributary/analytics/optimization/almgren_chriss.py"
      via: "ExecutionTrajectory for comparison input"
      pattern: "ExecutionTrajectory"
---

<objective>
Implement trade scheduling optimizer and strategy comparison utilities. The scheduler optimizes execution parameters given constraints. The comparison module enables side-by-side strategy evaluation before simulation.

Purpose: OPT-06 requires optimal slice timing and sizing. The scheduler wraps A-C trajectory generation with constraint handling. The comparison module lets users evaluate strategies before committing to simulation (Phase 4).

Output:
- `TradeSchedule` dataclass with constraints metadata
- `optimize_schedule()` function that finds optimal parameters given constraints
- `StrategyComparison` dataclass for holding multiple trajectories
- `compare_strategies()` function and summary table generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-optimization/03-RESEARCH.md

# Plan 1 provides A-C trajectory generation
# Plan 2 provides baseline strategies
# (Loaded during execution via SUMMARYs)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement trade scheduler optimizer</name>
  <files>
    src/tributary/analytics/optimization/scheduler.py
    tests/unit/test_scheduler.py
  </files>
  <action>
Create the trade scheduler that optimizes execution parameters given constraints.

**Create `src/tributary/analytics/optimization/scheduler.py`:**

1. Add module docstring:
   ```python
   """Trade scheduling optimizer for optimal execution.

   Provides constraint-aware schedule optimization that wraps Almgren-Chriss
   trajectory generation with practical execution constraints like participation
   rate limits and minimum slice sizes.
   """
   ```

2. Import dependencies:
   - `dataclasses.dataclass, field`
   - `typing.List, Optional`
   - `numpy as np`
   - From `.almgren_chriss`: `AlmgrenChrissParams, ExecutionTrajectory, generate_ac_trajectory`

3. Create `ScheduleConstraints` frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class ScheduleConstraints:
       """Constraints for trade schedule optimization.

       Attributes:
           max_participation_rate: Maximum fraction of interval volume (default 0.10)
           min_slice_size: Minimum trade size per interval (default 0)
           max_slice_size: Maximum trade size per interval (default inf)
           min_intervals: Minimum number of execution intervals (default 1)
           max_intervals: Maximum number of execution intervals (default None = unlimited)
       """
       max_participation_rate: float = 0.10
       min_slice_size: float = 0.0
       max_slice_size: float = float('inf')
       min_intervals: int = 1
       max_intervals: Optional[int] = None
   ```

4. Create `TradeSchedule` frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class TradeSchedule:
       """Optimized trade schedule with constraint metadata.

       Attributes:
           trajectory: The ExecutionTrajectory with optimal parameters
           constraints: Constraints that were applied
           intervals_used: Actual number of intervals in schedule
           max_slice_pct: Largest slice as percentage of total
           meets_participation_constraint: Whether all slices respect participation limit
           warnings: Any constraint violations or adjustments made
       """
       trajectory: ExecutionTrajectory
       constraints: ScheduleConstraints
       intervals_used: int
       max_slice_pct: float
       meets_participation_constraint: bool
       warnings: tuple = field(default_factory=tuple)
   ```

5. Create `optimize_schedule()` function:
   ```python
   def optimize_schedule(
       order_size: float,
       params: AlmgrenChrissParams,
       expected_interval_volume: float,
       risk_aversion: float = 1e-6,
       constraints: Optional[ScheduleConstraints] = None,
   ) -> TradeSchedule:
       """
       Optimize trade schedule given order and market parameters.

       Determines optimal number of intervals and generates trajectory
       while respecting participation rate and slice size constraints.

       Args:
           order_size: Total size to execute
           params: Calibrated AlmgrenChrissParams
           expected_interval_volume: Expected market volume per interval
           risk_aversion: Lambda for A-C optimization
           constraints: Optional ScheduleConstraints (uses defaults if None)

       Returns:
           TradeSchedule with optimized trajectory and constraint metadata

       Algorithm:
           1. Calculate minimum intervals from participation constraint
           2. Apply min/max interval constraints
           3. Generate A-C trajectory with final interval count
           4. Verify slices respect size constraints
           5. Return schedule with warnings if constraints violated
       """
   ```

   Implementation:
   - Use default constraints if None provided
   - Validate inputs (order_size > 0, expected_interval_volume > 0)
   - If invalid: return schedule with NaN trajectory and error warning

   - Calculate minimum intervals from participation constraint:
     - Max per-interval execution = expected_interval_volume * max_participation_rate
     - Minimum intervals = ceil(order_size / max_per_interval)

   - Apply interval constraints:
     - intervals = max(minimum_intervals, constraints.min_intervals)
     - If max_intervals set: intervals = min(intervals, constraints.max_intervals)

   - Generate A-C trajectory:
     - trajectory = generate_ac_trajectory(order_size, intervals, params, risk_aversion)

   - Calculate metrics:
     - max_slice_pct = trajectory.trade_sizes.max() / order_size * 100
     - max_slice_rate = trajectory.trade_sizes.max() / expected_interval_volume

   - Check participation constraint:
     - meets_participation = max_slice_rate <= constraints.max_participation_rate

   - Check slice size constraints:
     - If any slice < min_slice_size or > max_slice_size: add warning

   - Collect warnings list

   - Return TradeSchedule with all computed values

6. Create `calculate_optimal_intervals()` helper:
   ```python
   def calculate_optimal_intervals(
       order_size: float,
       expected_interval_volume: float,
       max_participation_rate: float = 0.10,
   ) -> int:
       """
       Calculate minimum intervals needed to respect participation constraint.

       Args:
           order_size: Total size to execute
           expected_interval_volume: Expected market volume per interval
           max_participation_rate: Maximum fraction of volume per interval

       Returns:
           Minimum number of intervals needed
       """
   ```

**Create `tests/unit/test_scheduler.py`:**

Test ScheduleConstraints:
- test_constraints_defaults
- test_constraints_custom_values
- test_constraints_is_frozen

Test TradeSchedule:
- test_schedule_creation
- test_schedule_is_frozen

Test optimize_schedule:
- test_optimize_basic (no constraints violated)
- test_optimize_respects_participation_rate
- test_optimize_minimum_intervals_from_participation
- test_optimize_respects_min_intervals_constraint
- test_optimize_respects_max_intervals_constraint
- test_optimize_large_order_needs_more_intervals
- test_optimize_small_order_single_interval
- test_optimize_warns_on_constraint_violation
- test_optimize_invalid_order_size
- test_optimize_invalid_volume

Test calculate_optimal_intervals:
- test_calculate_intervals_basic
- test_calculate_intervals_large_order
- test_calculate_intervals_small_order
- test_calculate_intervals_exact_fit
  </action>
  <verify>
  - File exists: `src/tributary/analytics/optimization/scheduler.py`
  - Tests pass: `pytest tests/unit/test_scheduler.py -v`
  </verify>
  <done>
  - ScheduleConstraints dataclass captures execution constraints
  - TradeSchedule wraps trajectory with constraint metadata
  - optimize_schedule() finds optimal intervals respecting constraints
  - Participation rate constraint determines minimum intervals
  - Warnings generated for constraint violations
  - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement strategy comparison and finalize exports</name>
  <files>
    src/tributary/analytics/optimization/comparison.py
    src/tributary/analytics/optimization/__init__.py
    src/tributary/analytics/__init__.py
    tests/unit/test_comparison.py
  </files>
  <action>
Create strategy comparison module and finalize all package exports.

**Create `src/tributary/analytics/optimization/comparison.py`:**

1. Add module docstring:
   ```python
   """Strategy comparison utilities for pre-simulation analysis.

   Enables side-by-side comparison of execution strategies before
   committing to simulation. Helps users understand trade-offs between
   strategies without running full backtests.
   """
   ```

2. Import dependencies:
   - `dataclasses.dataclass, field`
   - `typing.List, Optional`
   - `pandas as pd`
   - `numpy as np`
   - From `.almgren_chriss`: `ExecutionTrajectory`

3. Create `StrategyComparison` dataclass:
   ```python
   @dataclass
   class StrategyComparison:
       """Comparison of multiple execution strategies.

       Attributes:
           strategies: List of ExecutionTrajectory objects to compare
           baseline_name: Name of baseline strategy for relative comparison
           order_size: Original order size (for consistency check)
       """
       strategies: List[ExecutionTrajectory]
       baseline_name: str = "twap"
       order_size: Optional[float] = None

       def summary_table(self) -> pd.DataFrame:
           """
           Generate comparison summary as DataFrame.

           Returns:
               DataFrame with columns:
               - strategy: Strategy name
               - risk_aversion: Lambda parameter
               - expected_cost_bps: Estimated cost (0 if not computed)
               - num_slices: Number of execution intervals
               - max_slice_pct: Largest slice as % of total
               - min_slice_pct: Smallest slice as % of total
               - front_loaded: Boolean, True if first slice > last slice
           """
   ```

   Implementation of summary_table():
   - Create empty list for rows
   - For each strategy in self.strategies:
     - Extract metrics from trajectory
     - Handle NaN trade_sizes gracefully
     - Append dict to rows
   - Return pd.DataFrame(rows)

4. Create `compare_strategies()` function:
   ```python
   def compare_strategies(
       *trajectories: ExecutionTrajectory,
       baseline: str = "twap",
   ) -> StrategyComparison:
       """
       Create comparison from multiple trajectories.

       Args:
           *trajectories: ExecutionTrajectory objects to compare
           baseline: Name of baseline strategy for relative comparisons

       Returns:
           StrategyComparison with all strategies

       Example:
           comparison = compare_strategies(twap, vwap, ac_traj, baseline="twap")
           print(comparison.summary_table())
       """
   ```

   Implementation:
   - Validate at least 2 strategies provided
   - Extract order_size from first valid trajectory
   - Verify all trajectories have same order_size (warn if not)
   - Return StrategyComparison(list(trajectories), baseline, order_size)

5. Create `execution_profile_chart()` function (returns data, not plot):
   ```python
   def execution_profile_chart(
       comparison: StrategyComparison,
   ) -> pd.DataFrame:
       """
       Generate data for execution profile visualization.

       Returns DataFrame with columns:
       - period: Time period (0, 1, 2, ...)
       - strategy: Strategy name
       - holdings_pct: Remaining holdings as % of order size
       - trade_size_pct: Trade size as % of order size

       Use with plotting libraries (matplotlib, plotly) as desired.
       """
   ```

   Implementation:
   - Create list for rows
   - For each strategy:
     - Normalize holdings and trade_sizes to percentages
     - Create row per period
   - Return DataFrame

**Update `src/tributary/analytics/optimization/__init__.py`:**
```python
"""Optimization module for optimal execution strategies."""

from tributary.analytics.optimization.almgren_chriss import (
    AlmgrenChrissParams,
    ExecutionTrajectory,
    calibrate_ac_params,
    generate_ac_trajectory,
)
from tributary.analytics.optimization.strategies import (
    generate_twap_trajectory,
    generate_vwap_trajectory,
    generate_market_order_trajectory,
    get_volume_profile_from_db,
)
from tributary.analytics.optimization.scheduler import (
    ScheduleConstraints,
    TradeSchedule,
    optimize_schedule,
    calculate_optimal_intervals,
)
from tributary.analytics.optimization.comparison import (
    StrategyComparison,
    compare_strategies,
    execution_profile_chart,
)

__all__ = [
    # Almgren-Chriss
    "AlmgrenChrissParams",
    "ExecutionTrajectory",
    "calibrate_ac_params",
    "generate_ac_trajectory",
    # Baseline strategies
    "generate_twap_trajectory",
    "generate_vwap_trajectory",
    "generate_market_order_trajectory",
    "get_volume_profile_from_db",
    # Scheduler
    "ScheduleConstraints",
    "TradeSchedule",
    "optimize_schedule",
    "calculate_optimal_intervals",
    # Comparison
    "StrategyComparison",
    "compare_strategies",
    "execution_profile_chart",
]
```

**Update `src/tributary/analytics/__init__.py`:**
- Add all new exports from optimization subpackage
- Update __all__ list

**Create `tests/unit/test_comparison.py`:**

Test StrategyComparison:
- test_comparison_creation
- test_comparison_summary_table_columns
- test_comparison_summary_table_values
- test_comparison_with_different_strategies

Test compare_strategies:
- test_compare_two_strategies
- test_compare_multiple_strategies
- test_compare_validates_minimum_strategies
- test_compare_sets_order_size
- test_compare_warns_mismatched_order_sizes

Test execution_profile_chart:
- test_profile_chart_columns
- test_profile_chart_all_strategies_present
- test_profile_chart_holdings_percentages

Integration tests:
- test_full_comparison_workflow
- test_imports_from_analytics_package
  </action>
  <verify>
  - All tests pass: `pytest tests/unit/test_comparison.py -v`
  - All Phase 3 tests pass: `pytest tests/unit/test_almgren_chriss.py tests/unit/test_strategies.py tests/unit/test_scheduler.py tests/unit/test_comparison.py -v`
  - Full import test: `python -c "from tributary.analytics import compare_strategies, StrategyComparison, optimize_schedule, TradeSchedule; print('OK')"`
  </verify>
  <done>
  - StrategyComparison holds multiple trajectories for comparison
  - summary_table() generates DataFrame with key metrics
  - compare_strategies() creates comparison from trajectory objects
  - execution_profile_chart() provides data for visualization
  - All Phase 3 exports available from tributary.analytics
  - All tests pass
  </done>
</task>

</tasks>

<verification>
- All unit tests: `pytest tests/unit/test_scheduler.py tests/unit/test_comparison.py -v`
- Full Phase 3 test suite: `pytest tests/unit/test_almgren_chriss.py tests/unit/test_strategies.py tests/unit/test_scheduler.py tests/unit/test_comparison.py -v`
- Import test: `python -c "from tributary.analytics import optimize_schedule, compare_strategies, StrategyComparison"`
- Full workflow smoke test:
  ```python
  from tributary.analytics import (
      calibrate_ac_params,
      generate_ac_trajectory,
      generate_twap_trajectory,
      generate_vwap_trajectory,
      generate_market_order_trajectory,
      optimize_schedule,
      compare_strategies,
  )
  import numpy as np

  # Calibrate
  params = calibrate_ac_params(
      daily_volume=50000,
      daily_spread=0.02,
      daily_volatility=0.05,
      price=0.50,
  )

  # Generate strategies
  order_size = 5000
  twap = generate_twap_trajectory(order_size, duration_periods=10)
  vwap = generate_vwap_trajectory(order_size, volume_profile=np.array([1,2,3,2,1,1,2,3,2,1]))
  ac = generate_ac_trajectory(order_size, duration_periods=10, params=params, risk_aversion=1e-5)
  mkt = generate_market_order_trajectory(order_size)

  # Compare
  comparison = compare_strategies(twap, vwap, ac, mkt)
  print(comparison.summary_table())
  ```
</verification>

<success_criteria>
- optimize_schedule() produces optimal intervals respecting participation constraints
- TradeSchedule includes constraint metadata and violation warnings
- compare_strategies() creates StrategyComparison from multiple trajectories
- summary_table() generates clean DataFrame for strategy comparison
- execution_profile_chart() provides plotting-ready data
- All Phase 3 requirements (OPT-01 through OPT-06) satisfied
- All tests pass
- Full exports available from tributary.analytics package
</success_criteria>

<output>
After completion, create `.planning/phases/03-optimization/03-03-SUMMARY.md`
</output>
