---
phase: 04-simulation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/tributary/analytics/simulation/engine.py
  - src/tributary/analytics/simulation/runner.py
  - src/tributary/analytics/simulation/__init__.py
  - tests/unit/test_simulation_engine.py
  - tests/unit/test_strategy_runner.py
autonomous: true

must_haves:
  truths:
    - "Simulation engine processes market events in timestamp order"
    - "Orders are generated from ExecutionTrajectory slices at correct times"
    - "Each strategy runs on clean orderbook (isolated execution)"
    - "Runner can execute multiple strategies on same historical data"
    - "No lookahead bias - strategies only see past/current market state"
  artifacts:
    - path: "src/tributary/analytics/simulation/engine.py"
      provides: "Event-driven simulation loop"
      exports: ["SimulationEngine"]
    - path: "src/tributary/analytics/simulation/runner.py"
      provides: "Multi-strategy runner with isolated execution"
      exports: ["StrategyRunner", "StrategyRun"]
    - path: "tests/unit/test_simulation_engine.py"
      provides: "Engine tests"
      min_lines: 60
    - path: "tests/unit/test_strategy_runner.py"
      provides: "Runner tests"
      min_lines: 80
  key_links:
    - from: "src/tributary/analytics/simulation/engine.py"
      to: "src/tributary/analytics/simulation/fill_model.py"
      via: "FillModel import and usage"
      pattern: "from.*fill_model import FillModel"
    - from: "src/tributary/analytics/simulation/runner.py"
      to: "src/tributary/analytics/optimization"
      via: "ExecutionTrajectory import"
      pattern: "from tributary\\.analytics\\.optimization import ExecutionTrajectory"
---

<objective>
Build event-driven simulation engine and multi-strategy runner

Purpose: Create the orchestration layer that replays historical market data, executes strategy trajectories, and collects fill results. The runner enables comparing multiple strategies on the same data with isolated execution (no cross-strategy impact).

Output:
- SimulationEngine class that processes events in time order
- StrategyRunner class that runs multiple strategies with fresh fill models
- StrategyRun dataclass holding strategy trajectory and fill results
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-simulation/04-RESEARCH.md

# Prior plan outputs
@.planning/phases/04-simulation/04-01-SUMMARY.md

# Key existing code
@src/tributary/analytics/optimization/almgren_chriss.py - ExecutionTrajectory
@src/tributary/analytics/optimization/strategies.py - generate_twap_trajectory, etc.
@src/tributary/analytics/reader.py - QuestDBReader for historical data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement simulation engine</name>
  <files>
    src/tributary/analytics/simulation/engine.py
    src/tributary/analytics/simulation/__init__.py
    tests/unit/test_simulation_engine.py
  </files>
  <action>
Create SimulationEngine class that orchestrates event-driven execution.

**engine.py:**

```python
from collections import deque
from datetime import datetime, timedelta
from typing import Iterator, Optional
import pandas as pd

from .events import MarketEvent, OrderEvent, FillEvent
from .fill_model import FillModel
from tributary.analytics.optimization import ExecutionTrajectory


class SimulationEngine:
    """Event-driven execution simulation engine.

    Processes market events in timestamp order, generating orders from
    the provided execution trajectory and filling them against the orderbook.

    Key design:
    - Events processed in strict time order (no lookahead)
    - Orders generated at trajectory timestamps
    - Fill model handles execution against current market state
    """

    def __init__(
        self,
        fill_model: Optional[FillModel] = None,
    ):
        self.fill_model = fill_model or FillModel()
        self._current_market: Optional[MarketEvent] = None

    def run(
        self,
        trajectory: ExecutionTrajectory,
        market_data: pd.DataFrame,
        side: str,
        start_time: datetime,
        interval: timedelta,
    ) -> list[FillEvent]:
        """
        Run simulation of a single strategy.

        Args:
            trajectory: ExecutionTrajectory with trade_sizes to execute
            market_data: DataFrame with orderbook snapshots (from reader.query_orderbook_snapshots)
                Required columns: timestamp, mid_price, bid_prices, bid_sizes, ask_prices, ask_sizes
            side: 'buy' or 'sell' for all orders
            start_time: When to begin execution (arrival time)
            interval: Time between execution slices

        Returns:
            List of FillEvent objects, one per executed slice
        """
        # Implementation:
        # 1. Reset fill model state
        # 2. Build schedule of order times from trajectory
        # 3. Iterate through market_data in time order
        # 4. At each order time, find closest prior market event (no lookahead!)
        # 5. Generate OrderEvent and execute via fill_model
        # 6. Collect FillEvents
```

**Key behaviors:**
- Market data must be sorted by timestamp
- For each slice in trajectory, find the market state at or just before that slice time
- If no market data exists before a slice time, skip that slice (can't execute without market state)
- Fill model tracks liquidity consumption across slices

**Edge cases:**
- Empty market_data: return empty list
- Trajectory with 0 trade_sizes: return empty list
- Market data gaps: use last known market state (stale but valid)

**Tests (test_simulation_engine.py):**
- Test engine runs with simple trajectory and market data
- Test fills occur at correct timestamps
- Test slippage accumulated across slices
- Test no fills when no market data before order time
- Test market data sorted correctly
- Test buy and sell sides
  </action>
  <verify>
pytest tests/unit/test_simulation_engine.py -v
ruff check src/tributary/analytics/simulation/
  </verify>
  <done>
SimulationEngine processes market events in order, generates orders from trajectories at correct times, and returns FillEvents. No lookahead bias. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-strategy runner</name>
  <files>
    src/tributary/analytics/simulation/runner.py
    src/tributary/analytics/simulation/__init__.py
    tests/unit/test_strategy_runner.py
  </files>
  <action>
Create StrategyRunner class for comparing multiple strategies.

**runner.py:**

```python
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import List, Optional
import pandas as pd

from .engine import SimulationEngine
from .events import FillEvent
from .fill_model import FillModel
from tributary.analytics.optimization import ExecutionTrajectory


@dataclass
class StrategyRun:
    """Result of simulating one strategy.

    Attributes:
        trajectory: Original execution trajectory
        fills: List of FillEvents from simulation
        side: 'buy' or 'sell'
        start_time: Simulation start time (arrival time)
        interval: Time between slices
    """
    trajectory: ExecutionTrajectory
    fills: list[FillEvent]
    side: str
    start_time: datetime
    interval: timedelta


class StrategyRunner:
    """Run multiple strategies on the same historical data.

    Each strategy executes with:
    - Fresh fill model (isolated execution, no cross-strategy impact)
    - Same market data (fair comparison)
    - Same parameters (start time, interval, side)
    """

    def __init__(
        self,
        recovery_rate: float = 0.5,
        half_life_ms: float = 1000.0,
    ):
        """
        Args:
            recovery_rate: Liquidity recovery rate for fill models
            half_life_ms: Recovery half-life for fill models
        """
        self.recovery_rate = recovery_rate
        self.half_life_ms = half_life_ms

    def run_strategies(
        self,
        strategies: List[ExecutionTrajectory],
        market_data: pd.DataFrame,
        side: str,
        start_time: datetime,
        interval: timedelta,
    ) -> List[StrategyRun]:
        """
        Run all strategies on the same market data.

        Each strategy gets a fresh fill model - strategies do not impact
        each other's execution (parallel isolated execution per CONTEXT.md).

        Args:
            strategies: List of ExecutionTrajectory objects to simulate
            market_data: Historical orderbook data (same for all strategies)
            side: Trade direction for all strategies
            start_time: Execution start time (arrival time)
            interval: Time between execution slices

        Returns:
            List of StrategyRun objects, one per strategy
        """
        results = []

        for strategy in strategies:
            # Fresh fill model for each strategy (isolated execution)
            fill_model = FillModel(
                recovery_rate=self.recovery_rate,
                half_life_ms=self.half_life_ms,
            )
            engine = SimulationEngine(fill_model=fill_model)

            fills = engine.run(
                trajectory=strategy,
                market_data=market_data,
                side=side,
                start_time=start_time,
                interval=interval,
            )

            results.append(StrategyRun(
                trajectory=strategy,
                fills=fills,
                side=side,
                start_time=start_time,
                interval=interval,
            ))

        return results
```

**Key behaviors:**
- Each strategy gets its own FillModel instance (isolation)
- All strategies use the same market_data (fairness)
- Results are returned in same order as input strategies

**Tests (test_strategy_runner.py):**
- Test runner with 2+ strategies
- Test each strategy gets isolated execution (no cross-impact)
- Test results order matches input order
- Test strategies with different sizes execute correctly
- Test empty strategies list returns empty results
- Test market order vs TWAP shows different slippage patterns
  </action>
  <verify>
pytest tests/unit/test_strategy_runner.py -v
pytest tests/unit/test_simulation_engine.py tests/unit/test_strategy_runner.py -v
ruff check src/tributary/analytics/simulation/
  </verify>
  <done>
StrategyRunner executes multiple strategies on same data with isolated fill models. No cross-strategy impact. Results order matches input. Tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# All simulation tests pass
pytest tests/unit/test_simulation_engine.py tests/unit/test_strategy_runner.py -v

# Integration with Phase 3 strategies
python -c "
from datetime import datetime, timedelta, timezone
import pandas as pd
import numpy as np

from tributary.analytics.simulation import StrategyRunner, MarketEvent
from tributary.analytics.optimization import (
    generate_twap_trajectory,
    generate_market_order_trajectory,
)

# Create synthetic market data (10 snapshots over 10 seconds)
timestamps = [datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc) + timedelta(seconds=i) for i in range(10)]
market_data = pd.DataFrame({
    'timestamp': timestamps,
    'mid_price': [0.50] * 10,
    'bid_prices': [tuple([0.49, 0.48, 0.47])] * 10,
    'bid_sizes': [tuple([1000.0, 2000.0, 3000.0])] * 10,
    'ask_prices': [tuple([0.51, 0.52, 0.53])] * 10,
    'ask_sizes': [tuple([1000.0, 2000.0, 3000.0])] * 10,
})

# Generate strategies
twap = generate_twap_trajectory(order_size=3000, duration_periods=5)
market = generate_market_order_trajectory(order_size=3000)

# Run simulation
runner = StrategyRunner()
results = runner.run_strategies(
    strategies=[twap, market],
    market_data=market_data,
    side='buy',
    start_time=timestamps[0],
    interval=timedelta(seconds=1),
)

print(f'TWAP fills: {len(results[0].fills)}')
print(f'Market order fills: {len(results[1].fills)}')

twap_total_slippage = sum(f.slippage_bps * f.filled_size for f in results[0].fills) / 3000
market_slippage = results[1].fills[0].slippage_bps if results[1].fills else 0

print(f'TWAP weighted slippage: {twap_total_slippage:.2f} bps')
print(f'Market order slippage: {market_slippage:.2f} bps')
print('SUCCESS: Simulation engine and runner working correctly')
"
```
</verification>

<success_criteria>
1. SimulationEngine processes market events in timestamp order
2. Orders generated from ExecutionTrajectory at correct times
3. No lookahead bias (strategies only see past/current market state)
4. StrategyRunner provides isolated execution for each strategy
5. Multiple strategies can be compared on same market data
6. All tests pass, code is lint-clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-simulation/04-02-SUMMARY.md`
</output>
