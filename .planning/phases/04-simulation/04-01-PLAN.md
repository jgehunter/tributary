---
phase: 04-simulation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tributary/analytics/simulation/__init__.py
  - src/tributary/analytics/simulation/events.py
  - src/tributary/analytics/simulation/fill_model.py
  - tests/unit/test_simulation_events.py
  - tests/unit/test_fill_model.py
autonomous: true

must_haves:
  truths:
    - "MarketEvent captures orderbook state at a point in time"
    - "OrderEvent represents a trading instruction from a strategy"
    - "FillEvent captures execution result with slippage"
    - "Fill model consumes orderbook liquidity realistically"
    - "Liquidity partially recovers between execution slices"
  artifacts:
    - path: "src/tributary/analytics/simulation/events.py"
      provides: "Event type definitions (MarketEvent, OrderEvent, FillEvent)"
      exports: ["MarketEvent", "OrderEvent", "FillEvent"]
    - path: "src/tributary/analytics/simulation/fill_model.py"
      provides: "Realistic fill simulation with liquidity consumption"
      exports: ["FillModel"]
    - path: "tests/unit/test_simulation_events.py"
      provides: "Event type tests"
      min_lines: 50
    - path: "tests/unit/test_fill_model.py"
      provides: "Fill model tests"
      min_lines: 80
  key_links:
    - from: "src/tributary/analytics/simulation/fill_model.py"
      to: "src/tributary/analytics/cost_forecast.py"
      via: "estimate_slippage_from_orderbook import"
      pattern: "from tributary\\.analytics\\.cost_forecast import estimate_slippage_from_orderbook"
---

<objective>
Create event types and realistic fill model for execution simulation

Purpose: Establish the data structures (events) and fill logic that form the foundation of the event-driven simulation engine. The fill model must capture liquidity consumption and recovery to differentiate aggressive vs patient strategies.

Output:
- Frozen dataclasses for MarketEvent, OrderEvent, FillEvent
- FillModel class that walks the orderbook and tracks liquidity consumption
- Comprehensive unit tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-simulation/04-RESEARCH.md

# Key existing code
@src/tributary/analytics/cost_forecast.py - estimate_slippage_from_orderbook() for walk-the-book
@src/tributary/analytics/optimization/almgren_chriss.py - ExecutionTrajectory dataclass pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event type dataclasses</name>
  <files>
    src/tributary/analytics/simulation/__init__.py
    src/tributary/analytics/simulation/events.py
    tests/unit/test_simulation_events.py
  </files>
  <action>
Create the simulation subpackage with event type definitions.

**events.py:**
Create three frozen dataclasses following project conventions:

1. `MarketEvent` - Orderbook update from historical data replay:
   - timestamp: datetime
   - market_id: str
   - token_id: str
   - mid_price: float
   - bid_prices: tuple[float, ...] (tuple for frozen, not list)
   - bid_sizes: tuple[float, ...]
   - ask_prices: tuple[float, ...]
   - ask_sizes: tuple[float, ...]

2. `OrderEvent` - Order to be executed:
   - timestamp: datetime
   - strategy_name: str
   - slice_index: int
   - size: float
   - side: str ('buy' or 'sell')

3. `FillEvent` - Execution result:
   - timestamp: datetime
   - strategy_name: str
   - slice_index: int
   - requested_size: float
   - filled_size: float
   - avg_price: float
   - slippage_bps: float
   - levels_consumed: int
   - mid_price_at_fill: float (for cost calculation)

**__init__.py:**
Export all event types.

**Tests (test_simulation_events.py):**
- Test each event type can be instantiated
- Test events are frozen (immutable)
- Test tuple fields work correctly
- Test reasonable default edge cases
  </action>
  <verify>
pytest tests/unit/test_simulation_events.py -v
ruff check src/tributary/analytics/simulation/
  </verify>
  <done>
Three frozen event dataclasses defined with complete type hints. All tests pass. Events can be instantiated and are immutable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement fill model with liquidity consumption</name>
  <files>
    src/tributary/analytics/simulation/fill_model.py
    src/tributary/analytics/simulation/__init__.py
    tests/unit/test_fill_model.py
  </files>
  <action>
Create FillModel class that simulates realistic order execution.

**fill_model.py:**

```python
class FillModel:
    """Realistic fill model with liquidity consumption and recovery.

    Key behaviors:
    - Walks the orderbook to fill orders (uses estimate_slippage_from_orderbook)
    - Tracks consumed liquidity per side
    - Models partial recovery between slices based on time elapsed
    - Returns FillEvent with execution details
    """

    def __init__(
        self,
        recovery_rate: float = 0.5,
        half_life_ms: float = 1000.0,
    ):
        """
        Args:
            recovery_rate: Maximum fraction of liquidity that recovers (0-1)
            half_life_ms: Time for half of recoverable liquidity to return
        """
        self.recovery_rate = recovery_rate
        self.half_life_ms = half_life_ms
        self._consumed: dict[str, dict[int, float]] = {"buy": {}, "sell": {}}
        self._last_execution_time: datetime | None = None

    def reset(self):
        """Reset consumed liquidity state for new simulation run."""

    def execute(
        self,
        order: OrderEvent,
        market: MarketEvent,
    ) -> FillEvent:
        """Execute order against current market state."""
        # 1. Apply recovery if time has elapsed since last execution
        # 2. Adjust orderbook sizes by consumed amounts
        # 3. Call estimate_slippage_from_orderbook with adjusted book
        # 4. Track newly consumed liquidity
        # 5. Return FillEvent
```

**Liquidity consumption logic:**
- When order consumes level i, track consumed[side][i] += consumed_amount
- On next execution, subtract consumed amounts from orderbook sizes
- Apply exponential recovery: consumed *= (1 - recovery_factor)
- recovery_factor = 1 - 0.5^(time_elapsed_ms / half_life_ms) * (1 - recovery_rate)

**Edge cases:**
- Order larger than available liquidity: partial fill, unfilled_size > 0
- Empty orderbook: return FillEvent with filled_size=0, slippage_bps=NaN
- Zero time elapsed: no recovery applied

**Tests (test_fill_model.py):**
- Test basic fill against simple orderbook
- Test slippage increases with order size (market impact)
- Test liquidity consumption reduces available depth
- Test liquidity recovery over time
- Test partial fills when orderbook exhausted
- Test reset() clears state
- Test that TWAP-style small orders have less total slippage than single large order
- Test buy and sell sides both work correctly
  </action>
  <verify>
pytest tests/unit/test_fill_model.py -v
pytest tests/unit/test_simulation_events.py tests/unit/test_fill_model.py -v
ruff check src/tributary/analytics/simulation/
  </verify>
  <done>
FillModel correctly consumes liquidity, models recovery, and differentiates between aggressive and patient execution. Large orders show higher slippage than equivalent small slices. All tests pass.
  </done>
</task>

</tasks>

<verification>
```bash
# All simulation tests pass
pytest tests/unit/test_simulation_events.py tests/unit/test_fill_model.py -v

# Lint clean
ruff check src/tributary/analytics/simulation/

# Key behavioral test: large order slippage > sum of small order slippages
python -c "
from tributary.analytics.simulation import FillModel, MarketEvent, OrderEvent
from datetime import datetime, timezone

# Create test orderbook with 3 levels
market = MarketEvent(
    timestamp=datetime.now(timezone.utc),
    market_id='test',
    token_id='test',
    mid_price=0.50,
    bid_prices=(0.49, 0.48, 0.47),
    bid_sizes=(1000.0, 2000.0, 3000.0),
    ask_prices=(0.51, 0.52, 0.53),
    ask_sizes=(1000.0, 2000.0, 3000.0),
)

# Large order
model_large = FillModel()
large_order = OrderEvent(
    timestamp=datetime.now(timezone.utc),
    strategy_name='market',
    slice_index=0,
    size=5000.0,
    side='buy',
)
large_fill = model_large.execute(large_order, market)
print(f'Large order slippage: {large_fill.slippage_bps:.2f} bps')

# Small orders (TWAP-like)
model_small = FillModel()
total_small_slippage = 0.0
for i in range(5):
    small_order = OrderEvent(
        timestamp=datetime.now(timezone.utc),
        strategy_name='twap',
        slice_index=i,
        size=1000.0,
        side='buy',
    )
    # Reset to simulate fresh book (TWAP assumption: book recovers)
    model_small.reset()
    small_fill = model_small.execute(small_order, market)
    total_small_slippage += small_fill.slippage_bps * (small_fill.filled_size / 5000.0)
print(f'TWAP total slippage: {total_small_slippage:.2f} bps')

assert large_fill.slippage_bps > total_small_slippage, 'Market impact not captured!'
print('SUCCESS: Fill model differentiates aggressive vs patient execution')
"
```
</verification>

<success_criteria>
1. Event types (MarketEvent, OrderEvent, FillEvent) defined as frozen dataclasses
2. FillModel consumes liquidity from orderbook during execution
3. FillModel models partial liquidity recovery between slices
4. Large single orders have higher slippage than equivalent small slices
5. All tests pass, code is lint-clean
6. Module exports all public types from __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/04-simulation/04-01-SUMMARY.md`
</output>
