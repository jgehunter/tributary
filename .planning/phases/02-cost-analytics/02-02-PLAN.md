---
phase: 02-cost-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tributary/analytics/cost_forecast.py
  - src/tributary/analytics/__init__.py
  - tests/unit/test_cost_forecast.py
autonomous: true

must_haves:
  truths:
    - "User can forecast execution cost for a given order size using orderbook depth"
    - "Walk-the-book estimation provides expected execution price and slippage"
    - "Forecast includes levels consumed and fill status"
  artifacts:
    - path: "src/tributary/analytics/cost_forecast.py"
      provides: "Orderbook-based cost forecasting (walk the book)"
      exports: ["estimate_slippage_from_orderbook", "CostForecast"]
    - path: "tests/unit/test_cost_forecast.py"
      provides: "Unit tests for cost forecasting"
      min_tests: 12
  key_links:
    - from: "src/tributary/analytics/__init__.py"
      to: "cost_forecast.py"
      via: "module exports"
      pattern: "from tributary.analytics import estimate_slippage_from_orderbook"
---

<objective>
Implement orderbook-based cost forecasting using the "walk the book" algorithm.

Purpose: This is the PRIMARY method for estimating execution costs in thin liquidity markets like Polymarket. Unlike model-based approaches (square-root law), this directly measures available liquidity at each price level. Answers the question: "What would it cost to execute $X right now?"

Output: cost_forecast.py module with walk-the-book estimation and comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-cost-analytics/02-RESEARCH.md

# Phase 1 deliverables (orderbook data access)
@src/tributary/analytics/reader.py
@src/tributary/analytics/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Walk-the-Book Cost Forecasting</name>
  <files>
    src/tributary/analytics/cost_forecast.py
    tests/unit/test_cost_forecast.py
  </files>
  <action>
Create `cost_forecast.py` with:

1. `CostForecast` dataclass for results:
   ```python
   @dataclass
   class CostForecast:
       mid_price: float              # Reference price (best bid + best ask) / 2
       expected_execution_price: float  # VWAP across levels consumed
       slippage_bps: float           # Expected slippage in basis points
       levels_consumed: int          # Number of orderbook levels used
       fully_filled: bool            # Whether order can be completely filled
       unfilled_size: float          # Remaining size if partially filled
       total_cost: float             # Total dollar cost (size * expected_price)
   ```

2. `estimate_slippage_from_orderbook()` function:
   - Parameters: order_size, side ('buy'/'sell'), bid_prices (list), bid_sizes (list), ask_prices (list), ask_sizes (list)
   - Algorithm (from 02-RESEARCH.md Pattern 3):
     a. Calculate mid_price = (best_bid + best_ask) / 2
     b. For buy: iterate through asks (ascending price)
        For sell: iterate through bids (descending price)
     c. Accumulate size until order is filled
     d. Calculate volume-weighted average execution price
     e. Calculate slippage_bps using same convention as slippage.py (positive = cost)
   - Return CostForecast dataclass
   - Handle edge cases: empty orderbook, insufficient liquidity, zero order size

3. `forecast_execution_cost()` convenience function:
   - Parameters: reader (QuestDBReader), market_id, token_id, order_size, side, as_of_time (optional)
   - Queries latest orderbook snapshot and calls estimate_slippage_from_orderbook
   - Returns CostForecast or raises if no orderbook data available

Create `test_cost_forecast.py` with tests:
- Buy order consumes one level exactly
- Buy order spans multiple levels
- Sell order consumes one level exactly
- Sell order spans multiple levels
- Partial fill (insufficient liquidity)
- Empty orderbook returns appropriate error/NaN
- Zero order size edge case
- Slippage sign convention matches (positive = cost)
- Mid-price calculation verification
- Levels consumed count accuracy
- Large order exhausting all liquidity
- Order size equal to total book depth

Follow the research code patterns from 02-RESEARCH.md and existing test patterns.
  </action>
  <verify>
    - `python -c "from tributary.analytics import estimate_slippage_from_orderbook, CostForecast; print('OK')"`
    - `pytest tests/unit/test_cost_forecast.py -v` passes all tests
  </verify>
  <done>
    - CostForecast dataclass with all forecast fields
    - estimate_slippage_from_orderbook correctly walks the book
    - forecast_execution_cost convenience wrapper using QuestDBReader
    - 12+ unit tests passing
  </done>
</task>

<task type="auto">
  <name>Task 2: Export and Integration</name>
  <files>
    src/tributary/analytics/__init__.py
  </files>
  <action>
Update `__init__.py` to export:
- `CostForecast` dataclass
- `estimate_slippage_from_orderbook` function
- `forecast_execution_cost` function

Ensure clean import: `from tributary.analytics import estimate_slippage_from_orderbook, CostForecast, forecast_execution_cost`

Run lint check: `ruff check src/tributary/analytics/`
  </action>
  <verify>
    - `python -c "from tributary.analytics import estimate_slippage_from_orderbook, CostForecast, forecast_execution_cost; print('Imports OK')"`
    - `ruff check src/tributary/analytics/` passes
  </verify>
  <done>
    - All cost_forecast exports available from package
    - Lint passes
    - Requirement COST-08 satisfied
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. All 12+ unit tests pass: `pytest tests/unit/test_cost_forecast.py -v`
2. Imports work cleanly: `from tributary.analytics import estimate_slippage_from_orderbook, CostForecast, forecast_execution_cost`
3. Lint passes: `ruff check src/tributary/analytics/`
4. Manual verification: Buy order on ask side yields positive slippage (paid above mid)
</verification>

<success_criteria>
- COST-08: Forecast execution cost for a given order size - SATISFIED
- Walk-the-book algorithm correctly estimates cost from orderbook depth
- All unit tests pass
- Clean imports from analytics package
- Handles thin liquidity (partial fills) gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-cost-analytics/02-02-SUMMARY.md`
</output>
